import json

from pyutils.characterization.kernels.utils.checks import KernelsChecks

DELIMITER = '|'
NAME = 'name'
START_TIMESTAMP = 'ts'
DURATION = 'dur'


class ChromeTraceAnalyzer:
    """ A class that provides the functionality required to process the chrome trace of the studied networks. The
    chrome trace is generated by a functionality provided by PyTorch framework. """

    @staticmethod
    def read_trace_file(file_path):
        with open(file_path, 'r') as file_obj:
            records = json.load(file_obj)
            for record in records:
                if record[NAME] == 'forward':
                    records.remove(record)
        return records

    @staticmethod
    def extract_top_level_ops(records):
        # Assume first op is first top level one
        top_lvl_ops = list()
        curr_top_lvl_op = records[0]
        curr_top_lvl_op_start = curr_top_lvl_op[START_TIMESTAMP]
        curr_top_lvl_op_end = curr_top_lvl_op_start + curr_top_lvl_op[DURATION]
        top_lvl_ops.append(KernelsChecks.get_unified_kernel_name(curr_top_lvl_op[NAME]))

        for record in records:
            if record[START_TIMESTAMP] >= curr_top_lvl_op_end:
                # We found a new top-level op
                curr_top_lvl_op = record
                curr_top_lvl_op_start = curr_top_lvl_op[START_TIMESTAMP]
                curr_top_lvl_op_end = curr_top_lvl_op_start + curr_top_lvl_op[DURATION]
                top_lvl_ops.append(KernelsChecks.get_unified_kernel_name(curr_top_lvl_op[NAME]))

        return top_lvl_ops

    @staticmethod
    def process_trace_file(file_path):
        records = ChromeTraceAnalyzer.read_trace_file(file_path)
        top_lvl_ops = ChromeTraceAnalyzer.extract_top_level_ops(records)
        ops = list()
        for op in top_lvl_ops:
            if KernelsChecks.is_supported(op) or KernelsChecks.is_unsupported(op):
                ops.append(op)
        return ops
